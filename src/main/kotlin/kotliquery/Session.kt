package kotliquery

import kotliquery.action.ExecuteQueryAction
import kotliquery.action.ListResultQueryAction
import kotliquery.action.NullableResultQueryAction
import kotliquery.action.UpdateQueryAction
import org.slf4j.LoggerFactory
import java.io.InputStream
import java.math.BigDecimal
import java.net.URL
import java.sql.PreparedStatement
import java.sql.Statement
import java.sql.Timestamp
import java.time.*
import java.util.*

/**
 * Database Session.
 */
open class Session(
        open val connection: Connection,
        open val returnGeneratedKeys: Boolean = false,
        open val autoGeneratedKeys: List<String> = listOf(),
        var transactional: Boolean = false) {

    private val logger = LoggerFactory.getLogger(Session::class.java)

    private fun createPreparedStatement(query: Query): PreparedStatement {
        val stmt = if (returnGeneratedKeys) {
            if (connection.driverName == "oracle.jdbc.driver.OracleDriver") {
                connection.underlying.prepareStatement(query.statement, autoGeneratedKeys.toTypedArray())
            } else {
                connection.underlying.prepareStatement(query.statement, Statement.RETURN_GENERATED_KEYS)
            }
        } else {
            connection.underlying.prepareStatement(query.statement)
        }
        query.params.withIndex().forEach { param ->
            val v = param.value
            val idx = param.index + 1
            if (v == null) {
                stmt.setObject(idx, null)
            } else {
                when (v) {
                    is String -> stmt.setString(idx, v)
                    is Byte -> stmt.setByte(idx, v)
                    is Boolean -> stmt.setBoolean(idx, v)
                    is Int -> stmt.setInt(idx, v)
                    is Long -> stmt.setLong(idx, v)
                    is Short -> stmt.setShort(idx, v)
                    is Double -> stmt.setDouble(idx, v)
                    is Float -> stmt.setFloat(idx, v)
                    is ZonedDateTime -> stmt.setTimestamp(idx, Timestamp(Date.from(v.toInstant()).time))
                    is OffsetDateTime -> stmt.setTimestamp(idx, Timestamp(Date.from(v.toInstant()).time))
                    is Instant -> stmt.setTimestamp(idx, Timestamp(Date.from(v).time))
                    is LocalDateTime -> stmt.setTimestamp(idx, Timestamp(org.joda.time.LocalDateTime.parse(v.toString()).toDate().time))
                    is LocalDate -> stmt.setDate(idx, java.sql.Date(org.joda.time.LocalDate.parse(v.toString()).toDate().time))
                    is LocalTime -> stmt.setTime(idx, java.sql.Time(org.joda.time.LocalTime.parse(v.toString()).toDateTimeToday().millis))
                    is org.joda.time.DateTime -> stmt.setTimestamp(idx, Timestamp(v.toDate().time))
                    is org.joda.time.LocalDateTime -> stmt.setTimestamp(idx, Timestamp(v.toDate().time))
                    is org.joda.time.LocalDate -> stmt.setDate(idx, java.sql.Date(v.toDate().time))
                    is org.joda.time.LocalTime -> stmt.setTime(idx, java.sql.Time(v.toDateTimeToday().millis))
                    is java.util.Date -> stmt.setTimestamp(idx, Timestamp(v.time))
                    is java.sql.Timestamp -> stmt.setTimestamp(idx, v)
                    is java.sql.Time -> stmt.setTime(idx, v)
                    is java.sql.Date -> stmt.setTimestamp(idx, Timestamp(v.time))
                    is java.sql.SQLXML -> stmt.setSQLXML(idx, v)
                    is ByteArray -> stmt.setBytes(idx, v)
                    is InputStream -> stmt.setBinaryStream(idx, v)
                    is BigDecimal -> stmt.setBigDecimal(idx, v)
                    is java.sql.Array -> stmt.setArray(idx, v)
                    is URL -> stmt.setURL(idx, v)
                    else -> stmt.setObject(idx, v)
                }
            }
        }
        return stmt
    }

    private fun <A> rows(query: Query, extractor: (Row) -> A?): List<A> {
        return using(createPreparedStatement(query)) { stmt ->
            using(stmt.executeQuery()) { rs ->
                val rows = Row(rs).map { row -> extractor.invoke(row) }
                rows.filter { r -> r != null }.map { r -> r!! }.toList()
            }
        }
    }

    private fun warningForTransactionMode(): Unit {
        if (transactional) {
            logger.warn("Use TransactionalSession instead. The `tx` of `session.transaction { tx -> ... }`")
        }
    }

    fun <A> single(query: Query, extractor: (Row) -> A?): A? {
        warningForTransactionMode()
        val rs = rows(query, extractor)
        return if (rs.size > 0) rs.first() else null
    }

    fun <A> list(query: Query, extractor: (Row) -> A?): List<A> {
        warningForTransactionMode()
        return rows(query, extractor).toList()
    }

    fun forEach(query: Query, operator: (Row) -> Unit): Unit {
        warningForTransactionMode()
        using(createPreparedStatement(query)) { stmt ->
            using(stmt.executeQuery()) { rs ->
                Row(rs).forEach { row -> operator.invoke(row) }
            }
        }
    }

    fun execute(query: Query): Boolean {
        warningForTransactionMode()
        return using(createPreparedStatement(query)) { stmt ->
            stmt.execute()
        }
    }

    fun update(query: Query): Int {
        warningForTransactionMode()
        return using(createPreparedStatement(query)) { stmt ->
            stmt.executeUpdate()
        }
    }

    fun run(action: ExecuteQueryAction): Boolean {
        return action.runWithSession(this)
    }

    fun run(action: UpdateQueryAction): Int {
        return action.runWithSession(this)
    }

    fun <A> run(action: ListResultQueryAction<A>): List<A> {
        return action.runWithSession(this)
    }

    fun <A> run(action: NullableResultQueryAction<A>): A? {
        return action.runWithSession(this)
    }

    fun <A> transaction(operation: (TransactionalSession) -> A): A {
        try {
            connection.begin()
            transactional = true
            val tx = TransactionalSession(connection, returnGeneratedKeys, autoGeneratedKeys)
            val result: A = operation.invoke(tx)
            connection.commit()
            return result
        } catch(e: Exception) {
            connection.rollback()
            throw e
        } finally {
            transactional = false
        }
    }

}
